<?phprequire_once INCLUDE_PHP_LIB . '/Zend/Db/Table.php';require_once INCLUDE_PHP_LIB . '/Zend/Db/Table/Abstract.php';require_once INCLUDE_PHP_LIB . '/Zend/Db/Adapter/Pdo/Mysql.php';/**  * Classe Database ( CRUD ) *  */class Database extends Zend_Db_Table_Abstract {	/**	 * Nome da tabela que ser� utilizada para consultas	 * definida pela classe final que estende a Database	 * 	 * @var string $_name	 */	protected $_name;	/**	 * Chave(s) prim�ria(s) da tabela	 * 	 * @var int $primary	 */	protected $_primary;		/**	 * Chave(s) estrangeiras(s) da tabela	 * 	 * @var int $_foreignKeys	 */	protected $_foreignKeys;	/**	 * Colunas da tabela	 * 	 * @var array $_cols	 */	protected $_cols;	/**	 * Statement da ultima consulta executada	 * 	 * @var Zend_Db_Statement_Pdo $statement	 */	private $statement;		/**	 * n�mero de linhas totais de uma consulta, ignorando o limit 	 * @var int $statement	 */	private $_foundRows = 0;		/**	 * Construtor da classe	 * 	 * @param string $_name - Nome da tabela	 */	public function __construct( $_name = null ) {						try  {					if( null !== $_name )				$this->_name = $_name;				parent::__construct( $this->adapter );				$this->_setupTableName();				$this->_setupPrimaryKey();				$this->_cols = $this->_getCols();				$this->getAdapter()->getProfiler()->setEnabled( true );					} catch ( Exception $e ) {					LOG::set( $e->getMessage(), LOG::TYPE_SQL | LOG::TYPE_ERROR );			header("Location: ".WWW_ROOT."_app/Erro.php");						die;		}	}	/**	 * @param string $method	 * @param mixed $args	 */	public function __call( $method, $args ) {		if( function_exists( $method ) )			$this->{$method}( $args );		else			throw new Exception( 'O m�todo ('.$method.') solicitado n�o existe' );	}	/**	 * Busca o n�mero de registros da �ltima consulta executada	 * @return int $_foundRows	 */	public function getFoundRows(){		return $this->_foundRows;	}		/**	 * Faz tratamento de chaves prim�rias e estrangeiras	 * Retira chaves vazias n�o num�ricas	 */		private function tratarChaves(){				$dados = array();				foreach( $this->_cols as $key ) {									if( is_array($this->_primary) && in_array( $key, $this->_primary ) ) { // se � chave prim�ria				$isPK = true;			}else if( is_array($this->_foreignKeys) && in_array( $key, $this->_foreignKeys) ) { // se � chave estrangeira				$isFK = true;			}						if( isset($this->{$key}) && !( ($isPK || $isFK ) && ( empty( $this->{$key} ) && !is_numeric( $this->{$key} ) ) ) ) {				$dados[ $key ] = $this->{$key};			}								}				return $dados;	}		/**	 * Executa uma consulta e retorna o objeto com os dados da consulta	 * @param array/string $cols	 * @param string $where	 * @param string $group	 * @param int 	 */	public function listar( $cols = "*", $where = '', $limit = false, $group = '' ) {				if( null === $cols || empty( $cols ) )			$cols = '*';		if( !is_array( $cols ) && preg_match( '/,/', $cols ) )			$cols = explode( ',', preg_replace( '/ /', '', $cols ) );		$select = $this->select( Zend_Db_Table_Abstract::SELECT_WITH_FROM_PART )->from( $this->_name, $cols );		if( !empty( $where ) ) {			if( is_array( $where ) ) {				foreach( $where as $col => $value ) {					if( is_numeric( $col ) )						$select->where( $value );					else						$select->where( "{$col} = ?", $value );				}			} else {				$select->where( $where );			}		}		if( !empty( $group ) )			$select->group( $group );		$this->consultaSql( $select, $limit );		return $this;	}	public function select( $withFromPart = Zend_Db_Table_Abstract::SELECT_WITHOUT_FROM_PART ) {		return parent::select()->setIntegrityCheck( false );	}		/**	 * Executa as querys	 * n�o executa nenhum tratamento(where, order, limitPage) quando passado uma string no $select;	 * n�o UTILIZE ESTA fun��o SEM O CONDICIONAL "WHERE" NA SUA CONSULTA STRING	 * @param object/string $select	 * @param boolean $limit	 * @return object	 */	public function consultaSql( $select, $limit = false ) {				if( !isset($select) ) {			return false;					}		$conn = $this->getAdapter();						$filtroCancelamento = $this->getFiltroCancelamento();		$filtroRevenda = $this->getFiltroRevenda();				$filtros = '';		$filtros = $filtroCancelamento.' '.$filtroRevenda;				if( is_object($select) and $select instanceof Zend_Db_Select ) {				if( null !== $filtroCancelamento )				$select->where( $filtroCancelamento );				if( null !== $filtroRevenda )				$select->where( $filtroRevenda );				$order = $this->getOrder();				if( !empty( $order ) )				$select->order( $order );						if( $limit )				$select->limit( $this->getLinhasPorPagina(),$this->getNroPagina() );						//$select->limitPage( $this->getNroPagina(), $this->getLinhasPorPagina() );							$select = $select->__toString();			} elseif( is_string($select) ) {						if( trim($filtros) != '' )				$select = preg_replace('/WHERE/i', 'WHERE '.$filtros.' AND ', $select);						}									$select = preg_replace('/SELECT/i', 'SELECT SQL_CALC_FOUND_ROWS ', $select, 1);						$this->statement = $conn->query( $select );				$this->showProfile();				if( preg_match('/SQL_CALC_FOUND_ROWS/', $select) ) {			$this->_foundRows = $conn->fetchOne('SELECT FOUND_ROWS()');		}				$this->showProfile();		return $this;	}	/**	 * Executa o statement armazenado e	 * retorna um array contendo todas as linhas 	 * do conjunto de resultados	 */	public function getDados() {		return $this->statement->fetchAll();	}	/**	 * Executa o statement armazenado e	 * obt�m uma linha do conjunto de resultados	 */	public function getRegistro() {		return $this->statement->fetch();	}	public function getPares() {		return $this->statement->fetchAll( PDO::FETCH_KEY_PAIR );	}		/**	 * Executa a consulta ao banco de dados e armazena o statement	 * 	 * @param mixed $cols		- String/Array de colunas usados na clausula from	 * @param mixed $from		- String/Array O nome da tabela ou array associativo com chave ( alias ) e valor( nome da tabela )	 * @param array $join		- Alias da tabela como indice e o valor um array com condi��o, colunas e tipo de join( join, joinLeft, joinRight )	 * @param mixed $where		- String/Array A condi��o Where	 * @param mixed $group		- String/Array A(s) coluna(s) para o group by	 * @param bool $limit		- Limite de registro	 * @param string $having	- A condi��o having	 * 	 * @return Database	 */	public function consulta( $cols = "*", $from = "", $join = array(), $where = "", $group = "", $limit = false, $having = "" ) {		$select = parent::select( Zend_Db_Table_Abstract::SELECT_WITHOUT_FROM_PART )->setIntegrityCheck( false );		if( empty( $from ) || null === $from )			$from = $this->_name;		$from = array( 'A' => $from );		if( null === $cols )			$cols = '*';		if( !is_array( $cols ) && preg_match( '/,/', $cols ) )			$cols = explode( ',', preg_replace( "/ /", "", $cols ) );		$select->from( $from, $cols );		if( !empty( $join ) ) {			foreach( $join as $alias => $params ) {				$joinType = isset( $params[3] ) && !empty( $params[3] ) 								&& in_array( $params[3], array( 'join', 'joinLeft', 'joinRight' ) ) ? $params[3] : 'join';				if( !isset( $params[2] ) )					$params[2] = '';				$select->{$joinType}( array( $alias => $params[0] ), $params[1], $params[2] );			}		}		if( !empty( $where ) ) {			if( is_array( $where ) ) {				foreach( $where as $col => $value ) {					if( is_numeric( $col ) )						$select->where( $value );					else						$select->where( "{$col} = ?", $value );				}			} else {				$select->where( $where );			}		}		if( !empty( $group ) )			$select->group( $group );		if( !empty( $having ) )			$select->having( $having );		$this->consultaSql( $select, $limit );		return $this;	}	/**	 * Insere um novo registro	 * 	 * Se a chave prim�ria estiver setada na classe	 * e o parametro $forceUpdate esteja setado como true	 * retornamos a fun��o atualizar	 * 	 * @param array $data 	- Pares de coluna-valor	 * @param bool $forceUpdate - Caso seja setado como true retornamos o update	 * @return mixed 		- A chave prim�ria do registro inserido	 */	public function inserir( $data = null, $forceUpdate = false ) {				/**		 * Caso tenhamos recebido a matriz de coluna-valor		 * efetuamos o populate dos dados		 */				if( !empty( $data ) && is_array( $data ) ){			if( isset( $data['f_prefixo'] ) )				$this->populate( $data, $data['f_prefixo'] );			else				$this->populate( $data );		}					/**		 * Se a chave prim�ria foi setada e se forceUpdate � true(bool) entramos na condi��o		 */		if( !empty( $this->{$this->_primary[1]} ) && $forceUpdate ) {						/**			 * caso o parametro IDENTITY da chave primaria � true significa que esta chave			 * tem o parametro auto_increment ent�o retornamos o atualizar			 */			if( $this->_metadata[ $this->_primary[1] ]['IDENTITY'] == true ){				return self::atualizar();			} else {				if( $this->recordCount( "{$this->_primary[1]} = '{$this->{$this->_primary[1]}}'" ) )					return self::atualizar();			}		}				$dados = $this->tratarChaves();				/**		 * Executamos o insert retornando a chave prim�ria		 * do registro inserido		 */						try {			$id = $this->insert( $dados );						if(!empty($_SESSION['usr']['cod_usuario']))				Tracking::track( $_SESSION['usr']['cod_usuario'], (string)'INSERT', $this->_name, $this->getnomModulo(), "Insercao efetuada em {$this->getnomModulo()} com no de registro: {$id}" );						$this->showProfile();			return $id;		} catch( PDOException $e ) {							LOG::set( $e->getMessage() );			$this->showProfile();			print_r( $e->errorInfo );			exit;		}			}	/**	 * Atualiza o registro	 * 	 * Array com os pares de coluna-valor e	 * Clausula SQL para atualiza��o ou	 * utiliza��o do m�todo populate sem informar os parametros	 * 	 * @param array $data - Pares de coluna-valor	 * @param string $where - Clausula SQL	 * @return int - O n�mero de linhas atualizadas	 */	public function atualizar( $data = null, $where = null ) {		/**		 * Caso tenha sido informada data e where		 * retornamos a execu��o do update		 */								if( !empty( $data ) && null !== $where && is_string( $where ) ) {			$this->update( $data, $where );						if(!empty($_SESSION['usr']['cod_usuario']))				Tracking::track( $_SESSION['usr']['cod_usuario'], (string)'UPDATE', $this->_name, $this->getnomModulo(), "atualiza��o efetuada em {$this->getnomModulo()} no registro: {$this->{$this->_primary[1]}}" );			$this->showProfile();			return (int)$this->{$this->_primary[1]};		}				if( !empty( $data ) && null === $where ) {			if( in_array( $this->_primary[1], array_keys( $data ) ) ) {				$where = "{$this->_primary[1]} = '{$data[$this->_primary[1]]}'";				return $this->atualizar( $data, $where );			}		}		/**		 * Caso n�o tenha sido satisfeita a primeira condi��o		 * verificamos se a chave prim�ria foi setada		 */		if( empty( $this->_primary ) )			return null;		$where = '';		/**		 * Iteramos sobre as chaves prim�rias para montar 		 * a clausula SQL		 */		foreach( $this->_primary as $key )			$where .= "{$key} = '{$this->{$key}}' AND ";		// removemos o ultimo AND da clausula		$where = rtrim( $where, ' AND ' );				$data = $this->tratarChaves();				/**		 * Retornamos a execu��o da atualiza��o		 */		try {			$this->update( $data, $where );					if(!empty($_SESSION['usr']['cod_usuario']))				Tracking::track( $_SESSION['usr']['cod_usuario'], (string)'UPDATE', $this->_name, $this->getnomModulo(), "atualiza��o efetuada em {$this->getnomModulo()} no registro: {$this->{$this->_primary[1]}}" );			/** 			 * o update retorna as linhas afetadas, 			 * quando nenhum dado � atualizado as linhas afetadas � igual a 0			 * sendo assim sempre retornamos o valor da chave prim�ria da linha atualizada			 */			$this->showProfile();			return (int)$this->{$this->_primary[1]};		} catch( PDOException $e ) {			LOG::set( $e->getMessage() );					$this->showProfile();			print_r( $e->errorInfo );			exit;		}	}	/**	 * Exclui um ou mais registros	 * 	 * String com a chave prim�ria a ser removida ou	 * Array com as chaves prim�rias a serem removidas ou	 * String com a condi��o a ser removida	 * 	 * @param mixed $registro - String/Array com os valores das chaves prim�rias a serem removidas ou a condi��o a ser satisfeita	 */	public function excluir( $registro = null ) {		if( null === $registro || empty( $registro ) )			return;		/**		 * Caso o registro recebido seja um array de valores de chaves prim�rias		 * Iteramos sobre ele chamando a fun��o de forma recursiva		 */		if( !empty( $registro ) && is_array( $registro ) ) {			foreach( $registro as $id ) {				$this->excluir( $id );			}			return;		}		/**		 * Caso o registro n�o seja um numero executamos o delete direto		 * pois isso ser� uma condi��o		 */		if( !is_numeric( $registro ) ) {									try {								$id = $this->delete( $registro );							} catch(Exception $e) {								LOG::set( $e->getMessage() );								Throw $e; 						}						if(!empty($_SESSION['usr']['cod_usuario']))				Tracking::track( $_SESSION['usr']['cod_usuario'], (string)'DELETE', $this->_name, $this->getnomModulo(), "Exclus�o efetuada em {$this->getnomModulo()} no registro: {$registro}" );			$this->showProfile();			return $id;		}		/**		 * Quando nenhuma das condi��es acima		 * forem satisfeitas montamos a condi��o		 */		$where = "{$this->_primary[1]} = {$registro}";				/**		 * retornamos a execu��o do delete		 */		try {						$rows = $this->delete( $where );		} catch(Exception $e) {						LOG::set( $e->getMessage() );						Throw $e; 					}							if(!empty($_SESSION['usr']['cod_usuario']))			Tracking::track( $_SESSION['usr']['cod_usuario'], (string)'DELETE', $this->_name, $this->getnomModulo(), "Exclus�o efetuada em {$this->getnomModulo()} no registro: {$registro}" );		$this->showProfile();		return $rows;	}    /*     * Coisa feia e tempor�ria, feita para suprir um problema apresentando pelo conjunto PDO/PHP(5.3up)     * que n�o consegue efetuar o LOAD DATA INFILE nem mesmo com o modo LOCAL     * @param string query a ser executada     */    public function execSql( $select ){        // Verifica se a express�o 'LOAD DATA' est� contida no par�metro e redireciona caso falso        if(!preg_match('/LOAD DATA/i',$select)){            return $this->consultaSql( $select );        }        $adapter = $this->getAdapter()->getConfig();        mysql_connect($adapter['host'],$adapter['username'],$adapter['password']);        mysql_select_db($adapter['dbname']);        mysql_query($select);        return $this;    }}?>